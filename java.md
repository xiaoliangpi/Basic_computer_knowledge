# java

## java基本语法

标识符 与命名

关键字和保留字
关键字（keyword）的定义和特点
定义：被java语言赋予了特殊含义，用作专门用途的字符（字符串）
关键字中所有字母都是小写
比如class、interface、if、long、else等
true、false、null比较特殊，它们用于定义数据类型值的，当作关键字

保留字
java保留字：现有java版本上位使用，以后可能会作为关键字使用。
goto、const

2. 标识符
   java对各种变量、方法和类等要素命名时使用的字符序列称为标识符
   （与c很像）
   由26个英文字母大小写，0-9，_或$组成
   数字不可以开头
   不可以使用关键字和保留字，但是可以包含关键字和保留字。
   java严格区分大小写，长度无限制。
   但标识符不能包含空格。

3. java的名称命名规范（最好这样做）
   包含：多单词组成时，所有字母都小写：xxyyz
   类名、接口明：多单词组成时，所有单词的首字母大写：XxxYyy
   变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxYyyZzz
   常量名：所有字母都大写，多单词时每个单词用下划线连接：XXX_YYY

起名时，为了提高阅读性，尽量有意义“见名知意”
中文可以当标识符，但是不要这样写

#### 变量

变量
变量的概念：
内存中的一个存储区域
区域数据可以再同一类型范围内不断变化
是程序中最基本的存储单元，包含变量类型、变量名和存储值
作用是在内存中保存数据

java的每个变量必须先声明，后使用，这与c是一致的
变量都定义在其作用域内，出了作用域就失效了
同一个作用域内，不可以生命两个同名变量

java变量分类：按照数据类型
基本数据类型分为：

1. 数值型
   整数类型（byte，short，int，long）
   浮点类型（float，double）

2. 字符型（char）

3. 布尔型（boolean）


引用数据类型
类（class）字符串是一个类的类型

接口（interface）

数组（array）

二、根据变量在类中的位置，分为成员变量 和 局部变量


1. 整数类型：byte、short、int、long
   byte 1字节=8bit位 表示256个数 -128~127
   short 2字节       -2^15~2^15-1
   int   4字节       约21亿
   long  8字节

声明long型的变量时，必须以“l”或者“L”结尾
如 long l1 = 2343251154543L;
通常，定义整型变量时，定义为int类型

2. 浮点类型：float、double
   float  单精度 4字节 -3.403E38~3.403E38
   double 双精度 8字节 -1.798E308~1.798E308
   定义float类型的变量时，变量以“f”或者“F”结尾
   如： float f1 = 12.3F
   通常使用时，用double类型

3. 字符类型：char
   char 1字符=2字节
   定义char型变量，通常用一对‘ ’

  但是单引号中一定要放东西。

'\t'代表制表符

'\u'开头的表示字符的编码，如'\u0123'是一个中文字符。

想把特殊字符也显示出来，就在前面再加个\

如'\\\u'输出的就是\u

4. boolean型

   只能取两个值：true或者false



在java8中，带小数点的数默认为double类型，无法赋值给float。



String**不是**基本的数据类型！

String属于引用数据类型。

声明string类型变量时，初始化用一对““

string可以和8种基本数据类型变量做运算，且运算只能是连接运算。

如：

int number = 1001;

String numberStr = "学号"；

bool b1 = true;

String info = numberStr + number+true;

System.out.println(info);

这时输出的是：学号：1001true



需要注意：只有加号两边都是字符串，+才表示连接

如果字符串两边是' ' 一个char类型，它保存实际是ascii码。所以+表示ascii码相加。



运算符注意点：

&代表与运算，不管前后结果是真是假，都要运算

&&代表且，如果前面为假，后面就不运算了

|运算，不管前后结果是真是假，都要运算

||运算，只要前面为真，后面就不运算了



#### 位运算符

<<左移 3<<2=12:  3\*2\*2=12

\>>右移 3>>1 = 1  3/2=1

\>>>无符号右移，被移位的最高位无论是0是1，空缺位都补0。

&、|、^(异或)、~非



三元运算符：

结构：（条件表达式）？表达式1：表达式2

条件表达式的结果为boolean类型

根据条件表达式真或假，决定执行表达式1，还是表达式2

如果表达式为true，执行表达式1

表达式为false，执行表达式2

表达式1和表达式2需要是一个类型的。



#### 流程控制

顺序结构

分支结构  if……else……   switch（）：case

循环结构



从键盘获取不同类型的变量，需要使用Scanner类。

1. 导包：import java.util.Scanner;

2. Scanner 的实例化（创建一个scanner的对象） 

   ```
   Scanner scan = new Scanner(System.in);
   int score = scan.nextInt();
   ```



多个条件表达式之间是“互斥”关系（没有交集），判断语句在上面下面没有关系。

如果多个条件表达式之间有交集，就有影响。

```
switch（表达式）{
case 常量1：
	语句1；

//break；
case 常量2：
	语句2；
//break；
default：
	语句；
//break；
}
```



#### 数组

数组是引用数据类型。

int[] id;

id = new int[]{0,0,0,0};  或者 id = new int[5]; //动态初始化，只告诉数组长度，不初始化值。

String[] names = new String[5];

数组元素的默认初始化值



在JVM中，有**栈**（stack）存放局部变量、**堆**（heap）存放new出来的结构：对象，数组

方法区（函数），有**常量池**和**静态域**



一维数组的内存解析

如，int[] arr = new int[]{1,2,3}; 此时读到等式左边，int arr，java在**栈**中创建一个arr

然后右边 new int[]，java在**堆**中，创建了一个长度为3的数组，并把它的初始值都赋为0.

然后读取{1,2,3}，java把初始值0，替换为1,2,3.并把数组的**首地址**，放到栈的arr下面。

每次**new**一个对象、数组，都会在堆里开辟一个**新的地址，并且初始化**。



二维数组的内存解析 P153

行数是必须赋值的，列数可以不赋值。

String\[][]  arr4 = new String\[3][];      ->在栈中创建一个arr4，在堆中创建行数为3的一个String，存放指针。并把String的地址赋值给arr4.

arr4[1] = new String[4];   ->在堆中另外创建一个长度为4的String，并把首地址赋值给堆中String的第一行位置。



跟C语言的二维数组不同，java的每一行，都可以是变长的。

在动态初始化之后，int\[][]  arr =  new int\[2][];   可以对arr每一维进行初始化。如：arr[0] =new int[5];  意思代表，把new int[5]的地址值赋给arr



System.out.println(arr4[0])     // [I@16f65612，[代表一维数组，I代表int型

System.out.println(arr4)        // [[I@6d01d69c，[[代表二维数组，I代表int型

（引用类型的变量，存储的实际上是地址值）

 

import java.util.Arrays
数组的工具包，含有函数：

1. boolean equals(int[] a,int[] b);       判断两个数组**是否相等**，返回boolean类型。

2. String toString(int[] a);                输出数组信息。（以String的形式）

3. void fill(int[] a,int val);                  将指定值**填充**到数组中（填充同一个值）

4. void sort(int[] a);                           对数组进行**排序**

5. int binarySearch(int[] a,int key) ;      二分查找，找到返回索引，没找到返回负数

   // int index = Arrays.binarySearch(arr,10);



#### 常见异常

1. 数组角标越界：ArrayIndexOutOfBoundsExcetion

2. 空指针异常：NullPointerException             这个变量里面存放的是指针，但指针指向一个null



## 面向对象

1. java类及类的成员：属性、方法、构造器；代码块、内部类
2. 面向对象三大特征：封装性、继承性、多态性
3. 其他关键字：this、super、static、final、abstract、interface、package……



面向过程：强调功能行为，以函数为单位，考虑怎么做

面向对象：具备了功能的对象，以类/对象为最小单位，考虑谁来做



对象：包含属性（成员变量）和方法（函数）。

通过“对象.属性”或“对象.方法”调用对象的结构。



#### 内存解析

![image-20200830092340939](E:/MySQL.assets/image-20200830092340939.png)

**堆**（Heap），此内存区域，**存放对象实例**，几乎所有对象实例都可以在这分配内存。

**栈**（Stack），虚拟机栈，**存储局部变量**（方法中的变量，都是局部变量），包括基本数据类型（boolean、byte、char、short、int、float、long、double），对象引用，它不是对象本身，而是对象在堆内存放的首地址。

**方法区**（Method Area），存储**类信息、常量池、静态变量、即时编译器编译后的代码**。



成员变量：

直接定义在类的一对{}内

权限修饰符：private、public、protected

局部变量：		

声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量。

它们在内存中加载的位置：

成员变量：加载到堆空间中（非static）

局部变量：加载到栈空间中



一个函数的调用过程：

函数内的都是局部变量，因此放在栈空间中，创建了新的对象，放在堆空间中。指向地址在栈空间。

当函数调用结束，栈空间元素一个个被pop出来。JVM的垃圾回收机制，会将堆空间中，没有指针指向的那些对象回收掉。



匿名对象：

只调用一次。

new 对象.属性；或者   new 对象.方法； 



#### **方法的重载**

两同一不同：同一个类、相同函数名

​						参数列表不同、参数个数不同、参数类型不同

如想要进行排序，可以对int类型排序，是一个函数。

对char类型排序，又是一个函数。对float……



这时因为函数名相同，在调用时，如何指定是哪一个函数？

①函数名确定，②参数列表（可以自动类型提升）



可变个数形参。

如：

public void show(String ...str){

}

代表，可以传入很多个形参，形参类型都是String。但这种可变形参，必须放在最后。这也代表，可变个数形参，每个函数最多只能一个。



封装性：降低耦合。

封装性的体现：①不对外暴露的私有方法  ② 单例模式……

权限修饰符：四种权限可见性的大小，从小到大：private、不填、protested、public

![image-20200830162156123](E:/MySQL.assets/image-20200830162156123.png)



4种权限可以修饰类及类的内部结构：属性、方法、构造器、内部类。

修饰类的，只能用**public**和**不填**。



#### 构造器

任何一个类都有构造器（constructor）。它的作用是创建对象、初始化对象。

语法是：public class_name() {}

构造器权限默认和类权限是相同的。

如果没有定义时，系统默认提供一个空参的构造器。 但是一旦我们定义了一个类的构造器后，系统不再提供默认的空参构造器。

一个类中定义多个构造器，彼此构成重载。



它与set函数不同，设置set函数，表明把形参传递的值赋给对象。



属性赋值的方式：

① 默认初始化 		② 显式初始化（类中初始化）		③ 构造器中赋值		④ 通过“对象.方法”或"对象.属性"的方式赋值



**JavaBean**

JavaBean，符合以下标准的java类： ① 类是公共的；② 有一个无参的公共的构造器； ③ 有属性，且有对应的get、set方法



UML类图

![image-20200830184836289](E:/MySQL.assets/image-20200830184836289.png)



**this调用属性和方法**

为什么需要调用this？

在建造构造器、或者set函数时，传入的形参，通常与类中的属性名相同。

如：

public class Person{

​	int age;

​	public  Person(int age){

​		this.age = age;

}

}

this意为：当前对象。

**this调用构造器**

1. 在类的构造器中，可以使用this(形参列表)，调用本类中**其他**构造器。

2. this（形参列表）必须声明在首行。

3. 一个构造器中，最多只能调用一个本类的其他构造器。但构造器不能形成环（否则就出不去了）

如：

```
public class Person{
	int age;
	public  Person(){
		
	}
	public  Person(int age){
		this();      //此处调用的是Person()构造器。
		this.age = age;
	}
}
```



快捷方式，构造set、get函数：

source-generate getters and setters

构造器：source-generate constructor using fields



#### package 关键字的使用

1. 为了实现项目中类的管理，出现了包

2. 使用package声明类或接口所述的包，出现在首行
3. 包，命名小写，见名知意
4. 每 “ . ” 一次，代表一层文件目录。

同一个包下，不能命名通名的接口、类



**import关键字的使用**

import：导入

导入指定包下的类、接口

“xxx.*"的形式，表示导入xxx包下的所有结构。

如果使用的类或接口是java.lang包下定义的，则可以省略import结构。

当导入不同的包里，有重名的一个类。那么在调用时，需要将包 . 类的方式调用（全类名）。

import static：导入指定类或接口中的静态结构：属性或方法。



#### MVC设计模式

常用的设计模式之一，将程序分为是哪个层次：视图模型层，控制器层与数据模型层。

这种将程序输入输出、数据处理以及数据的展示分离开的设计模式。使程序结构变得灵活而且清晰。也描述了程序各个对象间的通信方式，降低了程序的耦合性。

![image-20200830214234922](E:/MySQL.assets/image-20200830214234922.png)

模型层 model 主要处理数据     

\>数据对象封装 model.bean/domain

\>数据库操作类 model.dao

\>数据库             model.db



控制层 controller 处理业务逻辑   

\>应用界面相关   controller.activity

\>存放fragment  controller.fragment

![image-20200830214748526](E:/MySQL.assets/image-20200830214748526.png)

根据功能，去定位包。



封装性的体现：

一、类的属性私有化

二、 方法（函数）私有化

三、 单例模式（构造器私有化）

四、 如果不希望类在包外被调用，可以将类设置为缺省的。



**eclipse 常用快捷键**

1. 补全代码：alt+/   非常好用！！
2. 快速修复：ctril + 1
3. 批量导包： 
4. 多行注释：ctrl + /
5. 大写小写转换：变成大写：ctrl+shift+x，变成小写：ctrl+shift+y



### 继承性

![image-20200831203458871](E:/MySQL.assets/image-20200831203458871.png)

子类可以继承父类的属性、函数等。

只需要在类名后面， 加上 extend father_name

继承性的**好处**：

1. 减少代码冗余，提高代码复用性
2. 便于功能扩展（子类都想加一个功能，这时只需要在父类中添加即可）
3. 为之后多态性的使用，提供前提



继承性的**格式**：class A extends B{}

A：子类、派生类、subclass

B：父类、超类、基类、superclass



体现：

1. 一旦子类A继承父类B以后，子类A中就获取了父类B中声明的**所有**的属性和方法。

2. 子类继承父类后，子类还可以声明自己特有的属性或方法，实现功能的拓展。



Java中关于继承性的**规定**：

1. 一个类可以被多个类继承
2. 类的单继承性：一个类只能有一个父类
3. 子父类是相对的，可以有多层继承，如一个父类A有一个子类B，这个子类B，还可以有另外一个子类C。（父类A的孙子C）这时，B对于C来说，是C的父类。
4. 子类C不仅包含父类B的属性和方法，还拥有间接父类A的所有属性和方法。



不同包的子类，可以调用另外一个包中父类的protected方法、属性。



#### 方法的重写（覆盖）

子类继承父类后，可以对父类中同名，同参数的方法，进行覆盖操作。

快捷键：alt+/

重写以后，当创建子类对象后，调用此同名同参数的方法时，实际执行的是，在子类中重写的方法。

重写的**规定**：

方法的声明： 权限修饰符 返回值类型 方法名（形参列表）throws 异常的类型{

}

1. 子类的叫重写的方法，父类中的叫被重写的方法。

2. 子类重写的方法的方法名和形参列表，与父类被重写的方法名和参数列表  相同

3. 子类重写的方法，权限大于等于父类被重写的方法。

   > 特殊情况：子类**不能**重写 **private**的父类的方法。

4. 返回值类型：

   > 父类返回值类型是 void，子类的也只能是void
   >
   > 父类返回值类型是A类型，子类的返回值类型，可以是A类，也可以是A类的子类。
   >
   > 父类的返回值类型，是基本数据类型，子类也必须是相同的返回类型（**不能**自动类型提升！！）。

5. 子类重写的方法，抛出的异常类型，不大于父类被重写的方法，抛出的异常类型



要么都是static，要么都不是static

但是只有非static 类型的，才叫重写。



#### Super关键字

super代表父类的。与this有相似之处。

子类调用父类的属性

如果子类父类有相同的属性，可以通过super. 属性来调用父类的属性。

super调用构造器。

1. 可以用super(形参列表)，给父类的构造器赋值，来创建父类。

2. super（形参列表）的使用，必须声明在子类构造器的首行。

   那么这就代表，super和this调用构造器时，只能选择一个。

3. 在构造器首行，没有显式地声明super和this，默认调用super（）

   

   这就代表，如果构造父类时，最好写一个**空构造器**！！

   

4. 在类的多个构造器中，至少有一个构造器中，使用了super（形参列表），调用父类的构造器。



**子类对象实例化过程**

1. 子类继承父类后，获取了父类声明的所有属性和方法。

   因此创建子类对象，在堆空间中，会加在所有父类中声明的属性。

2. 通过子类的构造器创造子类对象时，一定会直接或间接调用父类构造器……

   直到调用java.lang.Object类中空参的构造器为止。

   因此内存中有父类的结构，子类才可以调用父类的属性和结构。

   但是，父类的对象**并不是new出来的**，而是继承了父类的属性。



因此，对封装性又有了新的理解……

所谓封装，是把属性的地址隐藏起来，只有类内部才能够知道。

对外只保留了类的地址。只可以通过类的函数，来调用类内属性的地址。

#### Object类

1. 如果没有显示地声明，这个类包含父类，则此类继承与java.lang.Object类
2. 所有的类，都直接或间接地继承于 java.lang.Object类



1. Object类是所有java类的根父类。

2. 如果在类声明中未使用extends关键字，指明它的父类。默认父类是java.lang.Object类。
3. Object类 中的功能（属性、方法）具有通用性。
4. Object类只声明了一个空参的构造器。 



Object类中有finalize方法，它是JVM中自动的垃圾回收机制，在回收前会调用的一个函数

equals（）/toString（）



equals(Object obj) 方法和 == 的区别

1. == 是运算符。

   使用在基本数据类型变量，和引用数据类型变量中。

   基本数据类型变量，比较的是数据是否相同

   引用数据类型，比较是地址是否相同。



2. Object类中equals() 的定义：

   Object类中，定义的equals，和 == 相等。



3. String、Date、File、包装类等，都重写了Object类中的 equals() 方法

   因为这些类中，实际上比较的是实体内容。



4. 自定义的类，如果使用equals() 的话，也通常比较实体内容。

   因此需要重写。

   重写：（根据String类型来重写）

   ①先判断地址是否相同？相同直接return true；

   ② 判断是否是同一个类型？是的，再比较每个属性。

还可以自动生成 - source中



### 多态性

理解多态性：

一个事务的多种形态。

声明的类型，与new 的类型可以不同。**父类的引用指向子类的对象**。

如，父类person，子类man，woman。

person p1 = new man();

**此时，调用子类和父类同名，同参数的方法时，实际执行的是子类重写父类的方法。**

**但是，不能调用子类中有，父类中没有的方法。**



多态的使用。

有了对象的多态性后，在编译期，只能调用父类中声明的方法。虚拟方法调用

运行期，实际执行的是子类重写父类的**方法**。

编译：看左边； 	运行：看右边。

因为多态，是**运行时行为**。



多态的使用前提：

① 类的继承关系。

② 方法的重写。



**但属性没有多态性**。

属性只跟右边声明的类型有关。



#### 向下转型

使用强制类型转换符。![image-20200901112006239](E:/MySQL.assets/image-20200901112006239.png)

如：

Person父类，man子类，woman子类。

Person p1 = new man();

man p2 = (man) p1;



使用强转时，可能出现 **ClassCastException**的异常。

因为能够强转，是因为new的时候，用了多态性。将子类对象，赋给了父类的指针。



**instanceof关键字**

a instanceof A：判断对象a是否是类A的实例。

如果是，返回true，如果不是，返回false。



如果 a instanceof A 返回了 true。B是A的父类。

那么 a instanceof B 也一定返回true。



**toString()**

1. 当我们用toString（）输出一个对象的引用时，实际上就是调用当前对象的toString();

2. Object类中toString() 的定义：

   return getClass().getName()+"@"+Interger.toHexString(hashCode());

3. String、Date、File、包装类等，都重写了Object类中的toString（）方法。

4. 自定义类也可以重写toString（）方法。



### 包装类

针对八种基本数据类型，定义相应的引用类型：包装类（封装类）

就可以调用类中的方法。

![image-20200901193124664](E:/MySQL.assets/image-20200901193124664.png)



8中基本数据类型，对应的包装类，使得基本数据类型的变量具有类的特征。



包装类--->转换成基本数据类型：调用包装类Xxx的xxValue()
如：

Integer in1 = new Integer(12);

int i = in1.intValue();



基本数据类型--->转换成包装类，可以直接new，甚至，可以把它作为一个字符串，传入形参。

如：

i = 10;

Integer in1 = new Integer(i);

integer in2 = new Integer("10");

in1.equals(in2);   //返回的结果是true



自动装箱与拆箱：

基本数据类型--->包装类

int num2 = 10;

Integer in1 = num2;   //自动装箱



自动装箱，实际上是Integer内部，定义了IntegerCache结构。

保存了 -128 ~ 127范围的整数，只要赋值范围在 -128~127范围内时，就可以使用数组中的元素，不用new。

超出范围的，就是new了一个对象。





自动拆箱：包装类--->基本数据类型

int num3 = in1;     //自动拆箱。



**基本数据类型与String类的相互转换**

方式一：

```
//自动连接
int num = 10;
String str = num + "";
```



方式二：

调用String 重载的valueOf（Xxx xxx）

```
float f1 = 12.3f;
String str = String.valueOf(f1);    //"12.3"

double d1 = new Double(12.3);
String str2 = String.valueOf(d1);   //自动拆箱，并转换成String"12.3"
```



String类型--->转换成基本数据类型

调用**parseXxx**(String s)

如：

```
String str = "123";
int num = Integer.parseInt(str);
float f = Float.parseFloat(str);

String str2 = "true";
boolean b1 = Boolean.parseBoolean(str2);
```

boolean型比较特殊，只要不是true，都是false。

如：“true1”，也是false



注意：类型转换时，由于不匹配，如，要将“123abc”转换成int型

可能出现异常：NumberFormatException



对多态性的理解？

多态：是为了实现代码的通用性。

抽象类、接口的使用，肯定体现了多态性（抽象类、接口不能实例化）





#### Static关键字

1. static：静态的

2. static可以用来修饰：属性、方法、代码块、内部类

3. 使用static修饰属性：静态变量（类变量）。

   属性：按照是否使用static修饰，分为静态属性 vs 非静态属性（实例变量）

   

   静态变量：多个共享共享一个静态变量。当一个对象修改静态变量时，导致其他对象调用此静态变量时，是修改后的。

   静态变量，随着类的加载而加载。可以通过“类名.静态变量"的方式进行调用

   静态变量的加载早于对象的创建。

   由于类只会加载一次，静态变量在内存中也只会存在一份，存在**方法区的静态域**中。

   

   静态属性举例：System.out、Math.PI

   

4. 使用static修饰方法：静态方法

   ① 随着类的加载而加载，可以通过“类名.静态方法”来调用。

   ②静态方法中，只能调用静态方法和静态属性。 

   ​	非静态方法中，既可以调用静态方法或属性， 也可以调用非静态~~。



开发中，如何确定一个属性是否要声明为static？

​		所以对象共用一个的。不会随着对象不同而不同 。



方法声明为static？

​		操作静态属性的方法， 通常设置为 static的。

​		工具类中的方法：Math，Arrays（不专门为某个对象服务。而是所有对象都能调用）



### 单例（Singleton）设计模式

设计模式是解决问题的一种思考方式。

创建型模式，5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式

行为型模式，11中：策略模式……命令模式、备忘录模式、状态模式、访问者模式……



单例设计模式：

保证在整个软件系统中，对某类，**只能存在一个对象实例**。且该类只能提供一个取得其对象实例的方法。

首先，必须将类的构造器的访问权限设置为private。

**类内部**可以**产生**该类的对象。

类外部只能调用该类的某个静态方法，返回内部创建的对象。



实现:

#### **//饿汉式**

```
class bank{
//1. 私有化类的构造器
private Bank(){
}

//2. 内部创建类的对象
//4. 要求此对象也必须声明为静态的（这样才能够在静态方法中调用）（静态方法只能调用静态方法或静态变量）
private static Bank instance = new Bank();

//3. 提供公共的静态的方法，返回类的对象
public static Bank getInstance(){
	return instance;
}
}
```



**//懒汉式**

```
class Order{
	//1. 私有化类的构造器
	private Order(){
		
	}
	//2. 声明当前类对象，没有初始化
	//4. 此对象也必须声明为static
	private static Order instance = null;
	
	//3. 声明public、static的返回当前类对象的方法
	public static Order getInstance(){
		if(instance == null){
			instance = new Order();
		}
		return instance;
	}
}
```



饿汉式：

​			坏处：对象加载时间过长，占用内存

​			好处：线程安全的。

懒汉式：

​			好处：延迟对象的创建。

​			坏处：目前，线程不安全。



网站的计数器、应用程序的日志应用、数据库连接池

Application也是单例的典型应用

任务管理器、回收站，也是典型的单例应用。



main()方法的使用说明：

1. main()方法作为程序的入口
2. main()方法也是一个普通的静态方法
3. 调用的只能是静态方法，或静态变量，或者通过对象去调用方法。
4. main()方法，也可以作为我们与控制台交互的方式



### 代码块

一段{

}大括号里的内容。

1. 代码块的作用：用来初始化类、对象
2. 代码块如果有修饰的话，只能使用static
3. 静态代码块 vs 非静态代码块
4. 静态代码块

```
static{
	System.out.println("hello java world");
}
```

> 随着类的加载而执行。（调用）

> 只执行加载类的这一次。

> 初始化类的信息，如静态变量初始化。



5. 非静态代码块

```
static{
	System.out.println("hello java world");
}
```

> 随着对象的创建，而执行。（调用）

> 每创建一个对象，就执行一次非静态代码块

> 作用：在创建对象是，对对象的属性等进行初始化。
>
> 非静态代码块的执行，先于构造器的执行。



#### final关键字

final：最终的

1. final可以用来修饰的结构：类、方法、变量

2. final  用来修饰一个类：不能再有儿子了。（不能有子类了）

   ​					比如：String类、System类、StringBuffer类

3. final  用来修饰方法：此方法不可以被重写。

   ​					比如：Object类中 getClass() 方法

4. final  用来修饰变量：此时的“变量”就成为是一个常量。

   ​					final 修饰属性：在对象new出来的时候，final修饰的属性就必须有确定			的值。

   ·					final 修饰局部变量：一旦确定了值，在方法内就不能更改。



static final 用来修饰属性：全局常量。



#### 抽象类与抽象方法

父类一般设计得非常抽象，子类越来越具体。

如：父类是动物，子类分成了海豚科、猫科……猫科又分为豹子、狸花猫……



abstract关键字的使用

1. 可以用来修饰的结构：类、方法

2. abstract修饰类

   \>此类不能实例化（不能new出来）

   \>抽象类中一定有构造器。子类对象实例化时调用。

   

3. abstract 修饰方法：抽象方法

   \>抽象方法，只有方法的声明，没有方法体。如： public abstract void eat();

   \>抽象方法，只能存在在抽象类中

   \>如果子类不是抽象类，则需要重写父类**所有的**抽象方法。



4. abstract 不能用来修饰私有方法、静态方法、final的方法、final的类。这三种方法都不能被重写，而abstract必须重写。



#### 模板方法设计模式（TemplateMethod）

功能内部一部分实现是确定的，一部分实现是不确定的，这是可以把不确定的部分暴露出去，让子类去实现。

不确定的部分可以设置为抽象方法。



### 接口

有时必须从几个类中派生出一个子类。

有时必须从几个类中，抽取一些共同的行为特征。

接口，与类，是平行的，同等的一个阶级。



接口的使用

1. 接口 使用 interface 来定义

2. Java中，接口和类是并列的两个结构

3. 如何定义接口，定义接口中的成员

   ​	JDK7及以前：只能定义全局常量和抽象方法

   ​							\>全局常量： public static final的，书写时可以省略不写。

   ​							\>抽象方法：public abstract的

   ​	JDK8 ：除了全局常量和抽象方法外，还可以定义静态方法和默认方法（default）

   ​					\>接口中的静态方法，只能通过接口来调用。

   

4. 接口中，不能定义构造器的！意味着接口不可以实例化。

5. Java开发中，接口通过让类去实现的方式来使用。

   ​			类如果想实现（implements）接口，则必须重写接口中所有的抽象方法！！

如：

```
interface Fly{
	public abstract void fly();
}
class Plane implements Fly{
	@Override      //重写了接口中的抽象方法
	public void fly(){
	}
}
```

6. 接口可以多继承：弥补了Java的单继承性的局限性。

语法： class AA extends BB implements CC,DD,EE

```
interface Fly{
	public abstract void fly();
}
interface Attack{
}
class Bullet extends Plane implements Fly,Attack{
	@Override      //重写了接口中的抽象方法
	public void fly(){
	}
}
```

7. 接口与接口之间，可以多继承。

   子接口，继承了父接口所有的抽象方法。



接口的使用上，也体现了多态性。

如：函数调用的形参，是一个接口。

但是接口不可能被new出来（它没有构造器），只能通过它实现的一个类来进行调用。

因此最后传入形参的，是实现接口的那个类，new出来的对象。



应用：数据库的接口

JDBC，都是面向接口编程。因为每个数据库软件的具体操作不一样。

创建接口匿名实现类的匿名对象：P354



Tips：

父类和实现的接口中有同名同参数的方法。

优先调用的是父类的方法——类优先



### 代理模式（Proxy）

代理设计时为其他对象，提供一种代理，以控制对这个对象的访问。

P355

被代理类，不对某个属性做详细操作。

代理类，对被代理类的某个属性/方法做详细操作。



类的内部成员：

#### 内部类

一个事务的内部，有一个部分需要完整的结构。

可以创建一个类，但是这个类只为本事务服务。就创建内部类。

1. Java 允许将一个类A声明在另外一个类B中。
2. 局部内部类（代码块、构造器、方法内） vs 成员内部类（静态、非静态）



### 工厂模式

实现创建者和调用者的分离。将创建对象的具体过程屏蔽起来。



## 异常处理

在开发过程中，有些问题不是靠代码能够避免的，如：客户输入数据的格式、读取文件是否存在、网络是否始终保持通畅。

Java程序发生的异常事件有两类：

1. **Error**：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。

2. **Exception**：其他因编程错误或偶然的外在因素导致的一般性问题。

   可以使用针对的代码进行处理，如：

   ① 空指针访问

   ② 试图读取不存在的文件

   ③ 网络连接中断

   ④ 数组角标越界



对于这些错误，程序员最好提前考虑到错误的检测、错误消息的提示，以及错误的处理。



![image-20200903101146346](E:/MySQL.assets/image-20200903101146346.png)



一、异常体系结构

java.lang.Throwable

​		|----------java.lang.Error--------：一般不编写针对性的代码进行处理。

​		|----------java.lang.Exception----------：可以进行异常的处理

​				|----------编译时异常（checked）/受检异常

​								|----------IOException

​								|----------ClassNotFoundException

​				|----------运行时异常（unchecked）

​	

### Java异常处理

采用的异常处理机制，将可能出现异常处理的程序集中在一起，与正常的程序分开。

方式一：

​			try-catch-finally

方式二：

​			throws + 异常类型



异常处理机制一：抓抛模型

过程一：“抛”，程序在正常执行过程中，一旦出现异常，就会在异常代码处，生成一个对应异常类的对象。

​						并将此对象抛出。

​						一旦抛出对象以后，其后的代码就不再执行。



过程二：“抓”，异常的处理方式：① try-catch-finally   ② throws



#### try-catch-finally 的使用

```
try{
	//可能出现异常的代码
}catch(异常类型1 变量名1){
	//处理异常的方式1
}catch(异常类型2 变量名2){
	//处理异常的方式2
}
.......
finally{
	//一定会执行的代码
}
```

如：

```
@Test
public void test1(){
	String str = "abc";
	try{
		int num = Integer.parseInt(str);
		System.out.println("hello---1");
	}catch(NumberFormatException e){
		System.out.println("出现数值转换异常了，不要着急--")
		String getMessage();
		printStackTrace();
	}
	System.out.println("hello---2");
}
```

使用try，将可能出现异常的代码包装起来。

在执行过程中，一旦出现异常，就会生成一个对应异常类的对象。

然后根据此对象的类型，去catch中进行匹配。



一旦try中的异常对象，匹配到某个catch时，就进入catch中进行的异常的处理。

一旦处理完成，跳出当前try-catch结构。



常用的异常对象处理的方式：

① String getMessage()

② printStackTrace()



finally的大括号中，是一定会执行的语句。

即便上面catch 有了return，也依旧执行。

















# 项目调试

bug调试：

必要时添加输出语句

可以用Debug



### 单元测试

java中的JUnit单元测试

步骤：

1. 当前工程 - 右键选择： build path - add libraries - JUnit（next）- finish

2. 创建java类，进行单元测试

   此时的Java类要求：

   ①此类是公共的

   ②此类提供公共的无参的构造器。

   在类前、方法前，方法内  多添加必要的注释

3. 此类中声明单元测试方法：

   方法权限是public，没有返回值，没有形参

4. 此单元测试方法上，需要声明@Test，并在单元测试类中导入import org.junit.Test;

5. 声明好，可以在方法体内测试。

   左键双击单元测试方法名，右键：run as - JUnit Test

   也就是，写哪个单元，就可以测哪个单元。